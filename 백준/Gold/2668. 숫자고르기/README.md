# [Gold V] 숫자고르기 - 2668 

[문제 링크](https://www.acmicpc.net/problem/2668) 

### 성능 요약

메모리: 2024 KB, 시간: 0 ms

### 분류

깊이 우선 탐색, 그래프 이론, 그래프 탐색

### 제출 일자

2024년 1월 26일 17:16:01

### 문제 설명

<p>세로 두 줄, 가로로 N개의 칸으로 이루어진 표가 있다. 첫째 줄의 각 칸에는 정수 1, 2, …, N이 차례대로 들어 있고 둘째 줄의 각 칸에는 1이상 N이하인 정수가 들어 있다. 첫째 줄에서 숫자를 적절히 뽑으면, 그 뽑힌 정수들이 이루는 집합과, 뽑힌 정수들의 바로 밑의 둘째 줄에 들어있는 정수들이 이루는 집합이 일치한다. 이러한 조건을 만족시키도록 정수들을 뽑되, 최대로 많이 뽑는 방법을 찾는 프로그램을 작성하시오. 예를 들어, N=7인 경우 아래와 같이 표가 주어졌다고 하자.</p>

<p><img alt="" src="https://www.acmicpc.net/upload/images/u5JZnfExdtFXjmR.png" style="width: 262px; height: 61px; "></p>

<p>이 경우에는 첫째 줄에서 1, 3, 5를 뽑는 것이 답이다. 첫째 줄의 1, 3, 5밑에는 각각 3, 1, 5가 있으며 두 집합은 일치한다. 이때 집합의 크기는 3이다. 만약 첫째 줄에서 1과 3을 뽑으면, 이들 바로 밑에는 정수 3과 1이 있으므로 두 집합이 일치한다. 그러나, 이 경우에 뽑힌 정수의 개수는 최대가 아니므로 답이 될 수 없다.</p>

### 입력 

 <p>첫째 줄에는 N(1≤N≤100)을 나타내는 정수 하나가 주어진다. 그 다음 줄부터는 표의 둘째 줄에 들어가는 정수들이 순서대로 한 줄에 하나씩 입력된다.</p>

### 출력 

 <p>첫째 줄에 뽑힌 정수들의 개수를 출력하고, 그 다음 줄부터는 뽑힌 정수들을 작은 수부터 큰 수의 순서로 한 줄에 하나씩 출력한다.</p>

### 해설

<p>
 그래프의 싸이클의 원소를 찾는 문제입니다. key -> value 를 간선으로하는 그래프가 싸이클을 이룬다면, 싸이클을 이루는 key 원소의 집합과 value 원소의 집합은 동일하기 때문입니다.

 증명은 다음과 같습니다.

 1. Base
    N = 1인 경우 (key, value가 1개만 존재하는 경우)
    - Key == value인 경우 싸이클을 이룹니다. 또한,{key} = {value}이므로, 두 집합은 동일합니다.
    - Key != value인 경우 싸이클을 이루지 않습니다. 따라서, 공집합이기에 두 집합은 동일합니다.
 2. Step
    N -1일 때 싸이클을 이루는 key 원소의 집합과 value 원소의 집합은 동일하다면, N일 때도 key 원소의 집합과 value 원소의 집합은 동일하는 것을 증명해야 합니다. 이때, 새로 추가되는 간선을 e: { $v_1$, $v_2$ } 라고 하겠습니다.
    - e가 싸이클을 만들지 못할 때, 새로운 싸이클이 발생하지 않으므로 N - 1의 집합과 동일합니다
    - e가 싸이클을 만들때는, 그래프가 $v_2 -> v_i \cdots -> v_j -> v_1$ 와 같은 상황입니다. 해당 그래프에서 key 원소의 집합과 value 원소의 집합은 다음과 같습니다. $$ key = \{v_2, v_i, \cdots , v_j \}$$  $$ value = \{ v_i, \cdots , v_j, v_1 \}$$
    - 이후 간선 e가 추가되면 key 원소의 집합과 value 원소의 집합은 다음과 같습니다. $$ key = \{v_2, v_i, \cdots , v_j , v_1 \}$$  $$ value = \{ v_i, \cdots , v_j, v_1, v_2 \}$$
    - 따라서, 두 집합은 동일하고 N-1의 싸이클 집합도 동일하기에 N의 싸이클 집합도 동일합니다.

따라서, DFS를 이용해 탐색하여 싸이클을 찾으면 됩니다.

과정은 다음과 같습니다.

1. DFS를 이용하여 탐색합니다.
2. 만난 노드가 탐색의 시작점이라면, 싸이클입니다. 따라서, 지금까지 지나온 지점을 저장합니다.
3. 만난 노드가 탐색의 시작점이 아닌 지나온 노드라면 싸이클이 형성되지 않기에, 종료합니다.
4. 1 - 3번 과정을 N번 반복합니다.
5. 싸이클을 이루는 노드의 개수와 해당하는 노드를 출력합니다.

예외처리 과정에서 코드를 조금 더럽게 작성하였는데, 설명은 다음과 같습니다.
- Loop (한 엣지가 같은 노드에 붙어있는 경우)를 위해 노드 진입 시 stack에 삽입하였습니다.
- 또한, 싸이클을 이루는 노드에서 여러 번 호출될 수 있기에 res 배열에 싸이클을 이루면 1로, 이루지 않는다면 0으로 저장하였습니다. 따라서, 싸이클을 이루는 노드의 개수를 cnt 변수를 이용하여 따로 저장하였습니다.

시간 복잡도는 $O(N(N + N)) = O(N^2)$ 입니다. 더 줄일 수 있을 거 같은데 N이 작아서 그대로 진행하였습니다.
 
</p>
